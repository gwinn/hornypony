#!/bin/sh
### BEGIN INIT INFO
# Provides:          unicorn
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Manage unicorn servers
# Description:       Start, stop, restart unicorn servers for a ruby application.
### END INIT INFO

TEXT_RED=$(tput setaf 1)    # Red
TEXT_GRN=$(tput setaf 2)    # Green
TEXT_YEL=$(tput setaf 3)    # Yellow
TEXT_BLU=$(tput setaf 4)    # Blue
TEXT_PUR=$(tput setaf 5)    # Purple
TEXT_CYN=$(tput setaf 6)    # Cyan
TEXT_WHI=$(tput setaf 7)    # White
TEXT_RES=$(tput sgr0);      # Text color reset

set -e

while getopts c:i:e: option
do
  case "${option}"
  in
    c) COMMAND=${OPTARG};;
    i) INSTANCE=${OPTARG};;
    e) ENVIRONMENT=${OPTARG};;
  esac
done

if [ -z $ENVIRONMENT ]; then
  ENVIRONMENT="development"
fi

sig () {
  test -s "$PID" && kill -$1 `cat $PID`
}

run_task() {
  unset app_root
  unset jobs_exec
  unset cron_exec
  unset cron_file

  . /etc/unicorn/$1.conf

  PID=$app_root/tmp/pids/unicorn.pid
  CMD="cd $app_root; bundle exec unicorn -D -c $app_root/config/unicorn.rb -E $ENVIRONMENT"

  run () {
    if [ "$(id -un)" = "$user" ]; then
      eval $1
    else
      su -c "$1" - $user
    fi
  }

  case "$COMMAND" in
  start)
    sig 0 && echo >&2 "${TEXT_RED}${1} already running${TEXT_RES}" && return 0
    echo "${TEXT_GRN}${1} starting in ${ENVIRONMENT} environment${TEXT_RES}"
    run "$CMD"
    echo -e "${TEXT_GRN}\tapp started  OK${TEXT_RES}"
    if [ $jobs_exec ]; then
      run "cd $app_root; RAILS_ENV=$ENVIRONMENT bundle exec $jobs_exec -n 6 --queues=mailers,system,user start >/dev/null 2>&1"
      echo -e "${TEXT_GRN}\tjobs started OK${TEXT_RES}"
    fi
    if [ $cron_exec ]; then
      run "cd $app_root; RAILS_ENV=$ENVIRONMENT $cron_exec -c $cron_file start >/dev/null 2>&1"
      echo -e "${TEXT_GRN}\tcron started OK${TEXT_RES}"
    fi
    return 0
    ;;
  stop)
    sig QUIT \
    && echo "${TEXT_GRN}${1} is stoping${TEXT_RES}" \
    && echo -e "${TEXT_GRN}\tapp stoped  OK${TEXT_RES}" \
    && if [ $jobs_exec ]; \
      then run "cd $app_root; RAILS_ENV=$ENVIRONMENT bundle exec $jobs_exec stop >/dev/null 2>&1"; \
      echo -e "${TEXT_GRN}\tjobs stoped OK${TEXT_RES}"; fi \
    && if [ $cron_exec ]; \
      then run "cd $app_root; RAILS_ENV=$ENVIRONMENT $cron_exec -c $cron_file stop >/dev/null 2>&1"; \
      echo -e "${TEXT_GRN}\tcron stoped OK${TEXT_RES}"; fi \
    && return 0
    echo >&2 "${TEXT_RED}${1} not running${TEXT_RES}"
    ;;
  force-stop)
    sig TERM \
    && echo "${TEXT_GRN}${1} is force-stoping${TEXT_RES}" \
    && echo -e "${TEXT_GRN}\tapp stoped  OK${TEXT_RES}" \
    && if [ $jobs_exec ]; \
      then run "cd $app_root; RAILS_ENV=$ENVIRONMENT bundle exec $jobs_exec stop >/dev/null 2>&1"; \
      echo -e "${TEXT_GRN}\tjobs stoped OK${TEXT_RES}"; fi \
    && if [ $cron_exec ]; \
      then run "cd $app_root; RAILS_ENV=$ENVIRONMENT $cron_exec -c $cron_file stop >/dev/null 2>&1"; \
      echo -e "${TEXT_GRN}\tcron stoped OK${TEXT_RES}"; fi \
    && return 0
    echo >&2 "${TEXT_RED}${1} not running${TEXT_RES}" && return 0
    ;;
  restart)
    sig TERM \
    && run "$CMD" \
    && echo "${TEXT_GRN}restarting ${1}${TEXT_RES}" \
    && echo -e "${TEXT_GRN}\tapp restarted  OK${TEXT_RES}" \
    && if [ $jobs_exec ]; \
      then run "cd $app_root; RAILS_ENV=$ENVIRONMENT bundle exec $jobs_exec -n 6 --queues=mailers,system,user restart >/dev/null 2>&1"; \
      echo -e "${TEXT_GRN}\tjobs restarted OK${TEXT_RES}"; fi \
    && if [ $cron_exec ]; \
      then run "cd $app_root; RAILS_ENV=$ENVIRONMENT $cron_exec -c $cron_file restart >/dev/null 2>&1"; \
      echo -e "${TEXT_GRN}\tcron restarted OK${TEXT_RES}"; fi \
    && return 0
    echo >&2 "${TEXT_RED}${1} not running${TEXT_RES}" && return 0
    ;;
  *)
    echo >&2 "${TEXT_YEL}Usage: $(basename "$0") -c <start|stop|restart|force-stop> [-e <environment_name>][-i <instance_name>]${TEXT_RES}"
    exit 1
    ;;
  esac
}

if [ -z $INSTANCE ]; then
  for f in /etc/unicorn/*.conf
  do
    if test -f "$f"; then
      run_task $(basename "${f%%.*}")
    fi
  done
  exit 0
else
  run_task $INSTANCE
  exit 0
fi

